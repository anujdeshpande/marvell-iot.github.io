<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>AWS IoT Starter SDK: wmsdk/src/incl/sdk/drivers/mdev_i2c.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AWS IoT Starter SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_888e8a7168914c1639e2b782ab576ffb.html">wmsdk</a></li><li class="navelem"><a class="el" href="dir_259f8adb590fc33753e622d97b880658.html">src</a></li><li class="navelem"><a class="el" href="dir_a5320c50c325612ba11f999ef1d74fbb.html">incl</a></li><li class="navelem"><a class="el" href="dir_8d6a29e47fa7a432e99c9e8c3471a4bd.html">sdk</a></li><li class="navelem"><a class="el" href="dir_4abcf4425a2f20ed2d5999a4d787e735.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mdev_i2c.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inter-Integrated Circuit (I2C) Driver (TWSI)  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="mdev_8h_source.html">mdev.h</a>&gt;</code><br />
<code>#include &lt;lowlevel_drivers.h&gt;</code><br />
</div>
<p><a href="mdev__i2c_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a23e38bbb7263a6aa359d510a4aa2eb14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a23e38bbb7263a6aa359d510a4aa2eb14">NUM_I2C_PORTS</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a23e38bbb7263a6aa359d510a4aa2eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0f01fdf020d0f7467449b181fe95cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a8c0f01fdf020d0f7467449b181fe95cb">BIT10</a>&#160;&#160;&#160;(0x00000001 &lt;&lt; 10)</td></tr>
<tr class="separator:a8c0f01fdf020d0f7467449b181fe95cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cda1debde057b596766eba6a76daca0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cda1debde057b596766eba6a76daca0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT11</b>&#160;&#160;&#160;(0x00000001 &lt;&lt; 11)</td></tr>
<tr class="separator:a2cda1debde057b596766eba6a76daca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0a6acba8436baabcaa1e91fad6c0bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa0a6acba8436baabcaa1e91fad6c0bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT12</b>&#160;&#160;&#160;(0x00000001 &lt;&lt; 12)</td></tr>
<tr class="separator:aaa0a6acba8436baabcaa1e91fad6c0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965dc1748ab1cf91426bd04a2fe16ecf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a965dc1748ab1cf91426bd04a2fe16ecf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIT13</b>&#160;&#160;&#160;(0x00000001 &lt;&lt; 13)</td></tr>
<tr class="separator:a965dc1748ab1cf91426bd04a2fe16ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0090783ddbea3de8c9ef3dccd07e6c58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a0090783ddbea3de8c9ef3dccd07e6c58">I2C_CLK_100KHZ</a>&#160;&#160;&#160;(~(BIT12 | BIT13) &amp; 0x3000)</td></tr>
<tr class="separator:a0090783ddbea3de8c9ef3dccd07e6c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f892488b3eef20f2c39c55ac221ffb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#aa4f892488b3eef20f2c39c55ac221ffb">I2C_CLK_10KHZ</a>&#160;&#160;&#160;BIT13</td></tr>
<tr class="separator:aa4f892488b3eef20f2c39c55ac221ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad4bd544233a58a5134fd48bbe33bcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#abad4bd544233a58a5134fd48bbe33bcd">I2C_CLK_400KHZ</a>&#160;&#160;&#160;BIT12</td></tr>
<tr class="separator:abad4bd544233a58a5134fd48bbe33bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b126088561b1cb0e9883aa89cf596f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a9b126088561b1cb0e9883aa89cf596f9">I2C_DEVICE_SLAVE</a>&#160;&#160;&#160;BIT11</td></tr>
<tr class="separator:a9b126088561b1cb0e9883aa89cf596f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a991c799d3da0e90db2c5d387cf14d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a34a991c799d3da0e90db2c5d387cf14d">I2C_SLAVEADR</a>(x)&#160;&#160;&#160;(0x3ff &amp; (x))</td></tr>
<tr class="separator:a34a991c799d3da0e90db2c5d387cf14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0745964a9927ad536e6b3c46781d86d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a0745964a9927ad536e6b3c46781d86d8">I2C_10_BIT_ADDR</a>&#160;&#160;&#160;<a class="el" href="mdev__i2c_8h.html#a8c0f01fdf020d0f7467449b181fe95cb">BIT10</a></td></tr>
<tr class="separator:a0745964a9927ad536e6b3c46781d86d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4222668db14e185967cd42e83ba16888"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4222668db14e185967cd42e83ba16888"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_int_cb</b>) (I2C_INT_Type type, void *data)</td></tr>
<tr class="separator:a4222668db14e185967cd42e83ba16888"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afdc3c934109f2cdf53cbcc781b4cb87b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87b">I2C_DMA_MODE</a> { <a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87ba90a8f5a499159e6b3fd33204c180db56">I2C_DMA_DISABLE</a> = 0, 
<a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87ba163bf658f69acf181427c8bcea2a800f">I2C_DMA_ENABLE</a>
 }<tr class="separator:afdc3c934109f2cdf53cbcc781b4cb87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a6cbfda1b48383af9a2f56e81253c2c19"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a6cbfda1b48383af9a2f56e81253c2c19">i2c_status</a> { <a class="el" href="mdev__i2c_8h.html#a6cbfda1b48383af9a2f56e81253c2c19a05dd73a8328f83fab5b7c3c12601ed5b">I2C_INACTIVE</a> = 1 &lt;&lt; 0, 
<a class="el" href="mdev__i2c_8h.html#a6cbfda1b48383af9a2f56e81253c2c19a424c43f87ea826e0611e20b81d93dc48">I2C_ACTIVE</a> = 1 &lt;&lt; 1, 
<a class="el" href="mdev__i2c_8h.html#a6cbfda1b48383af9a2f56e81253c2c19a2e4932a1868432bff23103fac0127fdc">I2C_ERROR</a> = 1 &lt;&lt; 2
 }<tr class="separator:a6cbfda1b48383af9a2f56e81253c2c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92f342b35cccbd1847747f00196ea6c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a92f342b35cccbd1847747f00196ea6c7">i2c_drv_init</a> (I2C_ID_Type id)</td></tr>
<tr class="separator:a92f342b35cccbd1847747f00196ea6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd20560797dc8b2b3d8150f07f2b99f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a8fd20560797dc8b2b3d8150f07f2b99f">i2c_drv_set_clkcnt</a> (I2C_ID_Type i2c_id, int hightime, int lowtime)</td></tr>
<tr class="separator:a8fd20560797dc8b2b3d8150f07f2b99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a8d961d6b57ca48e0ed0820e334276"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a09a8d961d6b57ca48e0ed0820e334276">i2c_drv_rxbuf_size</a> (I2C_ID_Type i2c_id, uint32_t size)</td></tr>
<tr class="separator:a09a8d961d6b57ca48e0ed0820e334276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b875d0485501acb1a13e4cbd218004"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a09b875d0485501acb1a13e4cbd218004">i2c_drv_xfer_mode</a> (I2C_ID_Type i2c_id, <a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87b">I2C_DMA_MODE</a> dma_mode)</td></tr>
<tr class="separator:a09b875d0485501acb1a13e4cbd218004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ff990107af9b0e24827da74de11aed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open</a> (I2C_ID_Type i2c_id, uint32_t flags)</td></tr>
<tr class="separator:a03ff990107af9b0e24827da74de11aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbdebff1178f96e1b688778efd5c2d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#aacbdebff1178f96e1b688778efd5c2d7">i2c_drv_set_callback</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, i2c_int_cb event_cb, void *data)</td></tr>
<tr class="separator:aacbdebff1178f96e1b688778efd5c2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6cc6b794d04ea1b3b01707da729a21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a6e6cc6b794d04ea1b3b01707da729a21">i2c_drv_set_address</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, uint32_t flags)</td></tr>
<tr class="separator:a6e6cc6b794d04ea1b3b01707da729a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7828c26268bbd9b2b4a38ed96a7f6cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#ae7828c26268bbd9b2b4a38ed96a7f6cc">i2c_drv_wait_till_inactivity</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, uint32_t timeout_ms)</td></tr>
<tr class="separator:ae7828c26268bbd9b2b4a38ed96a7f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d241ccfc89f41d4e7950dae1704a13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a77d241ccfc89f41d4e7950dae1704a13">i2c_drv_close</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev)</td></tr>
<tr class="separator:a77d241ccfc89f41d4e7950dae1704a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa333b4fc87a6aee2832b4effdf56935a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#aa333b4fc87a6aee2832b4effdf56935a">i2c_drv_read</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, void *buf, uint32_t nbytes)</td></tr>
<tr class="separator:aa333b4fc87a6aee2832b4effdf56935a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c7d1d6fab666826addfc1304cff520"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#ad6c7d1d6fab666826addfc1304cff520">i2c_drv_slv_dma_read</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, void *buf, uint32_t nbytes)</td></tr>
<tr class="separator:ad6c7d1d6fab666826addfc1304cff520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e049971cf10df3a21e1d60bcc506aee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, const void *buf, uint32_t nbytes)</td></tr>
<tr class="separator:a3e049971cf10df3a21e1d60bcc506aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac434c43f4532e261982c428c7ecb35be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#ac434c43f4532e261982c428c7ecb35be">i2c_drv_dma_write</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, const uint8_t *buf, uint32_t nbytes)</td></tr>
<tr class="separator:ac434c43f4532e261982c428c7ecb35be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bb43bc707493294b91f35cbc9895db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#aa3bb43bc707493294b91f35cbc9895db">i2c_drv_dma_read</a> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev, uint8_t *buf, uint32_t nbytes)</td></tr>
<tr class="separator:aa3bb43bc707493294b91f35cbc9895db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb6f43f8a1ac74f6447c26f50f45443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a9cb6f43f8a1ac74f6447c26f50f45443">i2c_drv_timeout</a> (I2C_ID_Type id, uint32_t txtout, uint32_t rxtout)</td></tr>
<tr class="separator:a9cb6f43f8a1ac74f6447c26f50f45443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6b5788c8504b314940bd98cdc1bac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f6b5788c8504b314940bd98cdc1bac6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_drv_get_status_bitmap</b> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *mdev_p, uint32_t *status)</td></tr>
<tr class="separator:a0f6b5788c8504b314940bd98cdc1bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91655834ff2f3555845823e8dd10f2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab91655834ff2f3555845823e8dd10f2e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_drv_enable</b> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev)</td></tr>
<tr class="separator:ab91655834ff2f3555845823e8dd10f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa158f1f7075cc205cc229c36d1bf4686"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa158f1f7075cc205cc229c36d1bf4686"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_drv_disable</b> (<a class="el" href="struct__mdev__t.html">mdev_t</a> *dev)</td></tr>
<tr class="separator:aa158f1f7075cc205cc229c36d1bf4686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b24339ebac147a6cdd612d5fcd1e2a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mdev__i2c_8h.html#a9b24339ebac147a6cdd612d5fcd1e2a0">i2c_drv_deinit</a> (I2C_ID_Type id)</td></tr>
<tr class="separator:a9b24339ebac147a6cdd612d5fcd1e2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inter-Integrated Circuit (I2C) Driver (TWSI) </p>
<p>The 2-Wire Serial Interface (TSWI) unit is an interface between a 2-wire serial bus and the CPU. I2C Driver is meant to use TWSI hardware to communicate with external peripheral connected on I2C bus through application.</p>
<p>a. The speed of operation: There are standard two speeds at which I2C peripherals operate. 100KHz (Standard speed) and 400KHz (High speed). We have also provided 10KHz (Low speed) to handle any special case.</p>
<p>b. Slave address definition: Any valid transaction on I2C bus is associated with the device slave address and each I2C peripheral has it's own address. The I2C driver should be informed of the slave address of the peripheral that should be accessed.</p>
<p>c. Interface type: Internally TWSI can be connected to different hardware blocks. This identifies the device connection and specifies the interface type.</p>
<p>Note: The FIFO size of the hardware FIFO is 16 bytes</p>
<h1><a class="anchor" id="I2C_usage"></a>
Usage</h1>
<p>Follow the steps below to use I2C driver from applications</p>
<ol type="1">
<li>I2C driver initialization using <a class="el" href="mdev__i2c_8h.html#a92f342b35cccbd1847747f00196ea6c7">i2c_drv_init()</a>.</li>
<li>Open I2C device to handle using <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> call.</li>
<li>Use i2c_drv_write or <a class="el" href="mdev__i2c_8h.html#aa333b4fc87a6aee2832b4effdf56935a">i2c_drv_read()</a> calls to write or read data over I2C bus respectively.</li>
<li>Close the I2C port using <a class="el" href="mdev__i2c_8h.html#a77d241ccfc89f41d4e7950dae1704a13">i2c_drv_close()</a> to release the resources that the driver holds.</li>
</ol>
<p>Typical example:</p>
<p>Below peice of code demonstrates how to configure a I2C device whose slave address is I2C_ADDR interfaced on I2C1 for read/write operation. </p><div class="fragment"><div class="line">{</div>
<div class="line">   <a class="code" href="struct__mdev__t.html">mdev_t</a> *i2c_dev;</div>
<div class="line"></div>
<div class="line">   i2c_dev = <a class="code" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open</a>(I2C1_PORT,</div>
<div class="line">           <a class="code" href="mdev__i2c_8h.html#a34a991c799d3da0e90db2c5d387cf14d">I2C_SLAVEADR</a>(I2C_ADDR &gt;&gt; 1));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (ret != WM_SUCCESS)</div>
<div class="line">       <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">  uint8_t read_buf[4];</div>
<div class="line">  uint8_t write_buf[2];</div>
<div class="line">  buf[0] = 0x01;</div>
<div class="line">  buf[1] = 0x02;</div>
<div class="line">    <span class="keywordtype">int</span> read_len = <a class="code" href="mdev__i2c_8h.html#aa333b4fc87a6aee2832b4effdf56935a">i2c_drv_read</a>(i2c_dev, buf, 4);</div>
<div class="line">  <span class="keywordtype">int</span> write_len = <a class="code" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write</a>(i2c_dev, buf, 4);</div>
<div class="line">    <a class="code" href="mdev__i2c_8h.html#a77d241ccfc89f41d4e7950dae1704a13">i2c_drv_close</a>(i2c_dev);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>I2C_LCD_ADDR being a 8 bit address, was right shifted by 1 to make it valid 7 bit I2C address. This is slave dependant operation, please check slave device datasheet for more details.</dd></dl>
<p>I2C master start stop generation: The I2C IP automatically handles START and STOP condition generation. When first byte is put in TxFIFO (using the API <a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write()</a>), a START condition is generated and slave address is automatically sent on the bus. When all bytes from the TxFIFO are out on the bus the IP generates STOP condition on the bus. This point is important to note while designing the I2C application. For instance, the application may want to call <a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write()</a> multiple times during a single transaction. If the time gap between any successive call exceeds FIFO emptying time then a STOP will be generated automatically and things will not work as expected. A potential pitfall is adding debugging prints in between two calls to <a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write()</a> which may delay next write and the FIFO will may get emptied generating the unexpected STOP. After all the writes are complete you may call <a class="el" href="mdev__i2c_8h.html#ae7828c26268bbd9b2b4a38ed96a7f6cc">i2c_drv_wait_till_inactivity()</a> to ensure that all the writes are out on the bus an a STOP condition is generated signifying end of current transaction.</p>
<p>Conversely, if the application wishes to have two back to back calls to <a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write()</a> in separate transactions it needs to ensure that TxFIFO is empty before second call to <a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write()</a>. The API <a class="el" href="mdev__i2c_8h.html#ae7828c26268bbd9b2b4a38ed96a7f6cc">i2c_drv_wait_till_inactivity()</a> is provided for this purpose. Using this API will ensure the application can after this API returns with a success the earlier write is out on the bus and a STOP is generated. The following example illustrates the scenario:</p>
<ol type="1">
<li>Write a byte to I2C device at an address<ul>
<li>Write slave address</li>
<li>Write destination address</li>
<li>Write data to be written</li>
</ul>
</li>
<li>Use <a class="el" href="mdev__i2c_8h.html#ae7828c26268bbd9b2b4a38ed96a7f6cc">i2c_drv_wait_till_inactivity()</a> to ensure this transaction is complete.</li>
<li>Read a byte from some other address<ul>
<li>Write slave address</li>
<li>Write read address</li>
<li>Read data</li>
</ul>
</li>
</ol>
<p>Note that the API <a class="el" href="mdev__i2c_8h.html#ae7828c26268bbd9b2b4a38ed96a7f6cc">i2c_drv_wait_till_inactivity()</a> is not technically necessary for STOP to be generated. It only helps the application to sync itself with that particular bus event. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a8c0f01fdf020d0f7467449b181fe95cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT10&#160;&#160;&#160;(0x00000001 &lt;&lt; 10)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C specific parameters required for initialization </p>

</div>
</div>
<a class="anchor" id="a0745964a9927ad536e6b3c46781d86d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_10_BIT_ADDR&#160;&#160;&#160;<a class="el" href="mdev__i2c_8h.html#a8c0f01fdf020d0f7467449b181fe95cb">BIT10</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to specify 10 bit address mode </p>

</div>
</div>
<a class="anchor" id="a0090783ddbea3de8c9ef3dccd07e6c58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLK_100KHZ&#160;&#160;&#160;(~(BIT12 | BIT13) &amp; 0x3000)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Hardware Interface speed of operation -Standard (100Khz) </p>

</div>
</div>
<a class="anchor" id="aa4f892488b3eef20f2c39c55ac221ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLK_10KHZ&#160;&#160;&#160;BIT13</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Hardware Interface speed of operation -Low (10Khz) </p>

</div>
</div>
<a class="anchor" id="abad4bd544233a58a5134fd48bbe33bcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_CLK_400KHZ&#160;&#160;&#160;BIT12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Hardware Interface speed of operation -High (10Khz) </p>

</div>
</div>
<a class="anchor" id="a9b126088561b1cb0e9883aa89cf596f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_DEVICE_SLAVE&#160;&#160;&#160;BIT11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C flag to open driver as slave mode </p>

</div>
</div>
<a class="anchor" id="a34a991c799d3da0e90db2c5d387cf14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_SLAVEADR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(0x3ff &amp; (x))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to specify slave address of max 10 bits while opening a device the address would be truncated to 7 bits if I2C_10_BIT_ARRD is not set </p>

</div>
</div>
<a class="anchor" id="a23e38bbb7263a6aa359d510a4aa2eb14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_I2C_PORTS&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of I2C Hardware Interfaces available </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="afdc3c934109f2cdf53cbcc781b4cb87b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87b">I2C_DMA_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum to enable and disable DMA mode for I2C transfer </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afdc3c934109f2cdf53cbcc781b4cb87ba90a8f5a499159e6b3fd33204c180db56"></a>I2C_DMA_DISABLE&#160;</td><td class="fielddoc">
<p>Disable I2C DMA controller </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afdc3c934109f2cdf53cbcc781b4cb87ba163bf658f69acf181427c8bcea2a800f"></a>I2C_DMA_ENABLE&#160;</td><td class="fielddoc">
<p>Enable I2C DMA controller </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a6cbfda1b48383af9a2f56e81253c2c19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="mdev__i2c_8h.html#a6cbfda1b48383af9a2f56e81253c2c19">i2c_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration which indicates status of I2C </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6cbfda1b48383af9a2f56e81253c2c19a05dd73a8328f83fab5b7c3c12601ed5b"></a>I2C_INACTIVE&#160;</td><td class="fielddoc">
<p>I2C_INACTIVE : indicates that no ongoing I2C activity on the bus </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6cbfda1b48383af9a2f56e81253c2c19a424c43f87ea826e0611e20b81d93dc48"></a>I2C_ACTIVE&#160;</td><td class="fielddoc">
<p>I2C_ACTIVE : indicates I2C bus is busy. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6cbfda1b48383af9a2f56e81253c2c19a2e4932a1868432bff23103fac0127fdc"></a>I2C_ERROR&#160;</td><td class="fielddoc">
<p>I2C_ERROR : indicates that an error has occurred on I2C bus. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a77d241ccfc89f41d4e7950dae1704a13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close handle to I2C Device</p>
<p>This function closes the handle to I2C device and resets the I2C </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Handle to the I2C device returned by <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WM_SUCCESS on success, -WM_FAIL on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b24339ebac147a6cdd612d5fcd1e2a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_drv_deinit </td>
          <td>(</td>
          <td class="paramtype">I2C_ID_Type&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-initialize I2C Port</p>
<p>This function de-initializes I2C port. Note that if an I2C device has been opened using <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a>, it should be first closed using <a class="el" href="mdev__i2c_8h.html#a77d241ccfc89f41d4e7950dae1704a13">i2c_drv_close()</a> before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C device to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3bb43bc707493294b91f35cbc9895db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_dma_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from I2C using DMA</p>
<p>This function reads specified number of bytes from the I2C-RX-FIFO using DMA to copy data from I2C FIFO to RAM. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>mdev_t handle to the driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer containing data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Number of bytes to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success -WM_E_AGAIN in case of a timeout -WM_FAIL otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>This API is supported for master mode only </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac434c43f4532e261982c428c7ecb35be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_dma_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to I2C using DMA I2C Reads two bytes from interface as [Start][Slave address(write)]Byte0,Byte1[Stop] sequence on I2C</p>
<p>This function writes specified number of bytes to the I2C device Tx-FIFO; using DMA to copy data from RAM to I2C FIFO. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>mdev_t handle to the driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer containing data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Number of bytes to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success -WM_E_AGAIN in case the data length exceeds the max allowed length -WM_FAIL otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>This API is supported for master mode only </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="a92f342b35cccbd1847747f00196ea6c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_init </td>
          <td>(</td>
          <td class="paramtype">I2C_ID_Type&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize I2C Driver</p>
<p>This function initializes I2C driver. And registers the deivce with the mdev interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C device to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WM_SUCCESS on success </dd>
<dd>
-WM_FAIL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a03ff990107af9b0e24827da74de11aed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__mdev__t.html">mdev_t</a>* i2c_drv_open </td>
          <td>(</td>
          <td class="paramtype">I2C_ID_Type&#160;</td>
          <td class="paramname"><em>i2c_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open handle to I2C Device</p>
<p>This function opens the handle to I2C device and enables application to use the device. This handle should be used in other calls related to I2C device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_id</td><td>I2C port of the driver to be opened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td></td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Specification"></a>
of flags passed to i2c_drv_open:</h1>
<table class="doxtable">
<tr>
<th>BIT No </th><th>Use  </th></tr>
<tr>
<td>BIT[0:6] </td><td>I2C_SLAVE_ADDRESS (7 bit address mode) </td></tr>
<tr>
<td>BIT[0:9] </td><td>I2C_SLAVE_ADDRESS (10 bit address mode) </td></tr>
<tr>
<td>BIT10 </td><td>set for 10 bit address mode </td></tr>
<tr>
<td>BIT11 </td><td>set for slave mode operation </td></tr>
<tr>
<td>BIT[12 : 13] </td><td>speed of operation </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>handle to driver on success </dd>
<dd>
NULL otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aa333b4fc87a6aee2832b4effdf56935a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from I2C</p>
<p>This function reads specified number of bytes into the provided buffer from the I2C device. I2C Reads two bytes from interface as [Start][Slave address(read)]Rd Byte0, Rd Byte1[Stop] sequence on I2C</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Handle to the I2C device returned by <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer Pointer to an allocated buffer of size equal to or more than the value of the third parameter nbytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Number of bytes to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success </dd>
<dd>
-WM_E_AGAIN in case of a timeout (if timeout is enabled using the API i2c_drv_timeout) non-zero otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: read/write timeout is supported for master mode only </dd></dl>

</div>
</div>
<a class="anchor" id="a09a8d961d6b57ca48e0ed0820e334276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_rxbuf_size </td>
          <td>(</td>
          <td class="paramtype">I2C_ID_Type&#160;</td>
          <td class="paramname"><em>i2c_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set RX Ring-buffer size</p>
<p>This is optional call to change rx ringbuffer size. By default ringbuffer size is set to 128 bytes. </p><dl class="section note"><dt>Note</dt><dd>This call should be made after <a class="el" href="mdev__i2c_8h.html#a92f342b35cccbd1847747f00196ea6c7">i2c_drv_init()</a> and before <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> to over-write default configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_id</td><td>I2C ID of the driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of ring buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WM_SUCCESS on success </dd>
<dd>
-WM_FAIL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a6e6cc6b794d04ea1b3b01707da729a21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_set_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the slave address in i2c master mode.</p>
<p>This sets the slave address with which i2c module will perform subsequent IO operations in master mode. It can be optionally called after <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> and before performing any read/write operation. This function does not set the address of i2c module in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Handle to I2C device returned by <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td></td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Specification"></a>
of flags passed to i2c_drv_open:</h1>
<table class="doxtable">
<tr>
<th>BIT No </th><th>Use  </th></tr>
<tr>
<td>BIT[0:6] </td><td>I2C_SLAVE_ADDRESS (7 bit address mode) </td></tr>
<tr>
<td>BIT[0:9] </td><td>I2C_SLAVE_ADDRESS (10 bit address mode) </td></tr>
<tr>
<td>BIT10 </td><td>set for 10 bit address mode </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>WM_SUCCESS I2C address is set successfully. </dd>
<dd>
-WM_FAIL in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aacbdebff1178f96e1b688778efd5c2d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i2c_int_cb&#160;</td>
          <td class="paramname"><em>event_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set callback function to receive notifications</p>
<p>These notifications are actually hardware interrupts and are delivered in ISR context. The actual ISR handling is done by the driver. The notification may help the driver to manage its state machine.</p>
<dl class="section note"><dt>Note</dt><dd>Only a few interrupts out of the complete list are delivered to the application. Following is the list of interrupts delivered to the application:</dd></dl>
<ol type="1">
<li>I2C_INT_RD_REQ</li>
<li>I2C_INT_RX_OVER</li>
<li>I2C_INT_RX_DONE</li>
<li>I2C_INT_STOP_DET</li>
</ol>
<p>The description of the above interrupts are given in file {mc200/mw300}_i2c.h in the SDK.</p>
<dl class="section note"><dt>Note</dt><dd>Since the callbacks are delivered in ISR context, appropriate care needs to be taken. Especially, no other i2c_drv_* calls like <a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write()</a> or <a class="el" href="mdev__i2c_8h.html#aa333b4fc87a6aee2832b4effdf56935a">i2c_drv_read()</a> should be done from this callback as they may using blocking API's internally.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Handle to I2C device returned by <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_cb</td><td>Callback function defined by caller. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>user's private pointer that is passed as a parameter to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WM_SUCCESS if callback registered successfully. </dd>
<dd>
-WM_E_INVAL if invalid argument. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fd20560797dc8b2b3d8150f07f2b99f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_drv_set_clkcnt </td>
          <td>(</td>
          <td class="paramtype">I2C_ID_Type&#160;</td>
          <td class="paramname"><em>i2c_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hightime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lowtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set I2C driver clock(SCL) configuration</p>
<p>This is optional call to change I2C CLK frequency. By default the clock settings are set for standard loading conditions. I2C clock frequency may deviate from the standard 100K/ 400K due to bus loading. User may use this API to tune the I2C clk frequency. </p><dl class="section note"><dt>Note</dt><dd>This call should be made after <a class="el" href="mdev__i2c_8h.html#a92f342b35cccbd1847747f00196ea6c7">i2c_drv_init()</a> and before <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> to over-write default configuration.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_id</td><td>I2C ID of the driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hightime</td><td>min high time for I2C SCL (clock line) in nanoseconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowtime</td><td>min low time for I2C SCL (clock line) in nanoseconds Reducing the hightime or lowtime would increase the SCL frequency Default values for 100K are HCNT: 4000 LCNT:4700 Default values for 400K are HCNT: 600 LCNT:1300 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6c7d1d6fab666826addfc1304cff520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_slv_dma_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from I2C port in slave mode in DMA mode</p>
<p>This function reads specified number of bytes into the user buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Handle to the I2C device returned by <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer Pointer to an allocated buffer of size equal to or more than the value of the third parameter nbytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Number of bytes to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success </dd></dl>

</div>
</div>
<a class="anchor" id="a9cb6f43f8a1ac74f6447c26f50f45443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_drv_timeout </td>
          <td>(</td>
          <td class="paramtype">I2C_ID_Type&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txtout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxtout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set timeout for I2C read/write operations for master mode only.</p>
<p>This function sets the timeout for I2C read/write operations. It is disabled by default. This function needs to be called after init and before open for that particular port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>I2C port number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txtout</td><td>Tx timeout value in milli seconds, or zero to disable timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rxtout</td><td>Rx timeout value in milli seconds, or zero to disable timeout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7828c26268bbd9b2b4a38ed96a7f6cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_wait_till_inactivity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for I2C module inactivity.</p>
<p>Checks for and wait till the I2C module is inactive. For e.g. when <a class="el" href="mdev__i2c_8h.html#a3e049971cf10df3a21e1d60bcc506aee">i2c_drv_write()</a> returns, some bytes are still pending in the TxFIFO. If the application wishes to ensure that TxFIFO is empty before starting a new transaction this API needs to be called. Please check current file documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Handle to I2C device returned by <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>0 if to return immediately else spins for inactivity for max timeout_ms milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WM_SUCCESS I2C module is inactive. </dd>
<dd>
-WM_FAIL I2C module is still active. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e049971cf10df3a21e1d60bcc506aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__mdev__t.html">mdev_t</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to I2C I2C Reads two bytes from interface as [Start][Slave address(write)]Byte0,Byte1[Stop] sequence on I2C</p>
<p>This function writes specified number of bytes to the I2C device Tx-FIFO. </p><dl class="section note"><dt>Note</dt><dd>In slave mode if the user wants to enable low power modes, application should take wakelock in order to prevent slave from entering low power mode while serving the write request.</dd></dl>
<p>While operating in slave mdoe, if the master sends RD_REQ to the slave before i2c_drv_write call is made, slave Tx-FIFO remains empty and slave sends out dymmy data byte (i.e.0xff).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>mdev_t handle to the driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer containing data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbytes</td><td>Number of bytes to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success -WM_E_AGAIN in case of a timeout(if timeout is enabled using the API i2c_drv_timeout), -WM_FAIL otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>For a slave device waiting on RD_REQ, if time out occurs, no data is sent to master and i2c_drv_write returns 0 in this case.</li>
<li>read/write timeout is supported for master mode only </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="a09b875d0485501acb1a13e4cbd218004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_drv_xfer_mode </td>
          <td>(</td>
          <td class="paramtype">I2C_ID_Type&#160;</td>
          <td class="paramname"><em>i2c_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87b">I2C_DMA_MODE</a>&#160;</td>
          <td class="paramname"><em>dma_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set I2C transfer mode</p>
<p>This is an optional call to set I2C trasfer mode. By default I2C trasfer mode is set to I2C_DMA_DISABLE. This function should be called after <a class="el" href="mdev__i2c_8h.html#a92f342b35cccbd1847747f00196ea6c7">i2c_drv_init()</a> and before <a class="el" href="mdev__i2c_8h.html#a03ff990107af9b0e24827da74de11aed">i2c_drv_open()</a> call to enable DMA transfer mode. Master write and slave read over I2C bus using DMA are supported. Slave write and master read over DMA is not supported and hence use PIO (non DMA) mode for data transmit/receive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_id</td><td>Port ID of I2C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_mode</td><td><a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87ba90a8f5a499159e6b3fd33204c180db56">I2C_DMA_DISABLE</a> or <a class="el" href="mdev__i2c_8h.html#afdc3c934109f2cdf53cbcc781b4cb87ba163bf658f69acf181427c8bcea2a800f">I2C_DMA_ENABLE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WM_SUCCESS on success. </dd>
<dd>
-WM_FAIL on error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
